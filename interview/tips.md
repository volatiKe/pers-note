表达
* 慢语速
* 分点描述

系统介绍
* 定位：
	* 面向度小满理财基金交易
	* 付款的信息流 & 资金流
	* 异步清结算流程，没有直接的用户流量
* 业务：
	* 根据资金位置的不同分为：
		* 上行：支付 -> 销售
		* 下行：销售 -> 支付
* 清算：
	* 根据交易相关系统以文件形式提供的交易信息，执行清算动作（处理三要素），落地清算结果
	* 耦合交易相关逻辑
* 结算：
	* 将清算结果转化为实际的付款行为，通知支付中台完成结算动作
	* 关注整体资金流，感知并推进资金位置
	* 不耦合交易逻辑
* 对账：
	* 事后的旁路对账
		* CT 明细对账：系统间两两对账
			* 账证：清结算、支付 vs 交易单
			* 账账：商户出款 vs 入款
			* 账实：支付流水 vs 商户流水
		* 定点余额对账：综合当日15点时各类基金的清结算、支付、交易数据计算的未付款和15点余额对账

系统架构
* 在线批处理 + CT
* 在线批处理：
	* 下行清算、结算
	* 销售清结算
* CT：
	* 上行清算、结算
	* 对账

业务流程
* 支付：
	* 卡支付 + 日切后百付宝渠道上行 + T+1 其他渠道上行 + T+1 的正向数据报送
* 清结算：下行款
	* 交易确认后清算
		* 解析新交易核心数据进行逆向数据报送
		* 旧交易核心在处理完确认后触发下行清算
* 支付中台资产互转：
	* 余额盈买基金：
		* 基金交易请求支付落基金收款
			* 支付请求余额盈发起赎回
				* 赎回发起成功：互转关系 I
				* 发起失败：互转关系 F
		* 如果基金申购撤单
			* 如果此时互转关系仍为 I
				* 全部退：推 F
					* 尝试请求余额盈赎回撤单
				* 部分退：推 S（全部余额盈赎回资金会到基金申购户）
					* 构建部分退款流水
						* 基金申购户到中间户
						* 中间户到余额盈赎回户
						* 余额盈赎回户到卡
		* 等余额盈下行款
			* 如果此时互转关系仍为 I，互转关系推 S
				* 落余额盈付款单
				* 资金划拨
			* 如果互转关系为 F
				* 余额盈赎回资金付款到卡
	* 基金赎回到余额盈：
		* 基金赎回信息流清结算请求支付
			* 落基金付款单
			* 支付请求余额盈发起申购
			* 默认一定成功，互转关系推 S
		* 异步拉起余额盈收款流程
			* 落余额盈收款单
		* 基金赎回资金流清结算请求支付
			* 资金划拨
		* 如果余额盈申购确认失败退款
			* 互转关系 S（全部余额盈赎回资金会到基金申购户）
				* 余额盈申购户到中间户
				* 中间户到基金赎回户
				* 基金赎回户到卡
* 余额盈快赎：
	* 用户级别的流量从交易打到支付
	* 每两个资金位置之间落付款流水
	* CT 批量扫 I 付款流水做汇总请款
	* 资金到账后触发付款资金划拨

稳定性
* 准确（资损防控）：
	* 人工操作：
		* double check 等
	* api 加固：
		* 接口调用：diam
		* 文件的 md5
	* 系统设计：
		* 错误码判定：只判定明确成功和明确失败，非预期错误码直接人工介入
		* 幂等控制：明确幂等错误码，幂等id的唯一性控制
		* 防并发：一锁二判三更新，数据库底层唯一索引兜底
		* 一致性：事务，状态机控制下的查单补偿、直接补偿，主从延迟，对账
		* 兼容：新老服务切换，新老数据的兼容性
		* 状态机：终态不可逆，状态推进前的准入判断
		* 业务处理：有收才有退、业务校验
		* 流程设计：人工保证的专款专用
	* 运维
		* 线上线下环境隔离
* 时效：
	* 定时任务 + 人工审批 + 系统自动批处理
	* 主要靠监控发现问题
* 其他：
	* 监控：服务端口，数据状态，接口错误率
	* 安全：diam
	* 可用：集群部署、bns 负载均衡

资损问题
* 高端运营活动线下补打款重复打款
	* [20220520 活动后台打款重复打款资损 (duxiaoman-int.com)](https://zhishi.duxiaoman-int.com/knowledge/HFVrC7hq1Q/eyzDp1Jx9p/nbLu5Sr5Ly/V6gZaMvJX5pf9d)
		* 打款的 excel 上传了两次，每次生成一个批次，第一次的作废
		* 第二次打款后业务反馈只有 200 条打款成功
		* 没有补打款逻辑，增加了按批次号的接口
		* 操作后发现重复打款数据
		* 联系支付，提供 uid 冻结账户禁止提现
		* 临时写代码进行退款
	* 根本原因：
		* 分页逻辑问题，超过 200 条捞不到
		* 新增的逻辑没有判断作废批次，导致作废批次的代打款数据也被打款
	* 改进：
		* 不允许未经过评审的直接代码修改运行和人工操作
		* 完成代客打款等流程规范
		* 梳理存量老系统
		* 人工打款不允许在打款系统批量处理，应由业务系统请求

预案
* 增加 2 批次
	* 每次修改任务依赖、起停任务 优化为 两份 sql 单
* 使用恒生上报
	* 操作手册
* 打款文件错误
	* 第一时间拦截付款
	* 和各方接口人确认修复方案，接口人注意观察线上影响
	* 执行修复方案
		* 如赎回方式错误，则两方分别修数据
		* 文件缺数据，则补发新文件
	* 观察及确认执行结果
	* 恢复临时修改的配置

业务复杂点：资产互转
* 资金回来：
	* 基金赎回到余额盈
	* 基金赎回到余额盈做提前转购
	* 基金赎回到余额盈 + T05 垫资做提前转购
		* 转购发起时机的计算
		* 垫资资金的划拨
		* 可垫资基金的维护
		* 垫资基金逆向数据的报送
		* 转购失败数据的退款
* 改造为资金不回来：
	* 根据赎回数据在一清时识别赎转购数据进行二清（根据公式计算转购时间）
	* 二清结果流经 paycenter + trade 走转购和申购流程
	* 转购失败则 trade 请求 paycenter 走退款（资金未到）
	* 清算消费消息得知转购结果
	* 回写监管报送数据中转购相关的数据中并判定数据完整性（二清结果落地时带有转购成功或失败时相关时间字段，报送数据时按照数据上报日匹配这些时间捞取二清数据，判定数据是否都到终态）
	* 转购失败的数据走下行款流程付款转退款
* 改造的意义：
	* 恒生系统下线的必要条件之一
	* 相比资金回流 dxm 的转购流程，资金不回流的赎转购资金时效更快（即使是 T05 垫资，15 点前赎回确认后就发余额盈申购申请，申购资金也在第二天才到销售监管户，资金不回流对于 T0 赎回清算的基金，相当于余额盈的申购资金当天就到了销售监管）

优点
1. 架构清晰，一清二清解耦，每个流程都有解析、校验、清算（三要素）
2. 领域划分明确，清算耦合交易，结算只关注清算结果，批次映射资金流，明细映射资金分配

改进
* 技术：
	* 大文件处理
	* 信息流不必过结算
	* 文件交互可以替换为接口交互或消息消费，但需要其他机制得只单 TA 数据传输的完整性
* 业务：
	* 付款的实时清结算，如 0 元购退款时想将资金退至用户银行卡，由于支付资金为运营垫付，无法走原路退款只能走付款，但这种交易类的付款必须要经过清结算，而清结算暂不支持明细级的实时清结算
		* 接口或消息消费
		* 清算计算付款对象和付款金额，结算时间就是实时
		* 交易请求时，这笔订单必须是无效的申请单，否则资金可能会被划走
		* 严格一点的话清算可以计算这笔订单有效的话资金划拨的时间，过了时间后无法通过校验，或者查正向款的清算数据是否包括这笔订单
		* 结算部分的职责类比逆向款的话，需要感知资金此时的位置（查支付中台这笔订单支付成功），资金确实处于商户中才可以发起付款
	* 结算单引入结算时间，搭建账户系统，完善对账机制
		* 账务系统主要职责是记账和控制出款
		* 需要清结算触发记账，因为记账周期需要和交易行为对应，支付中台不感知交易行为相关的时间
		* 明细维度结算时可以查账务系统判断该笔订单的资金是否到达，做到专款专用

技术难点：销售结算批处理的可重入性
* 会临时调整清算天数，所以有重复出批次的 case，需要取消之前的批次
	* 重出批次由人工触发，不能阻塞页面
	* 所以取消的实际逻辑是将批次作废
	* 而明细每次都使用 insertOrUpdate 的方式处理
	* 出批次是捞出的明细字段携带版本号，有效明细的版本号必须为空、当前批次（重入）、当日无效批次

为什么重构
* 收敛服务、配置、解耦 activiti 引擎，降低维护成本
* 重新确定领域边界
* 便于后期承载更多清结算业务逻辑，如下线恒生清结算

重构做了哪些事
* 功能的平迁
* 确认领域职责，迁出领域外逻辑，抽象清结算流程的模型
* 切流

遇到的问题
* 清结算：
	* 存在资金流先于信息流到达的 case：
		* 上午 5002 的机构赎回资金带回了用户赎回的资金
		* 用户是要赎回到余额盈
		* 上午触发了结算但转购信息流还没触发清结算
	* 切流时，不能分别对信息流和资金流打标，因为信息流和资金流在支付中台里是同一条数据的不同状态
		* 信息流处理
			* 已经能查到资金流数据：信息流不打标
			* 查不到资金流数据：信息流打标
		* 资金流处理
			* 查信息流且打标：资金流打标
			* 查不到信息流或未打标：资金流不打标

切流
* 直接从切 settle 说
* 流量复制
	* 清算修改代码
	* 清算双写老结算
	* 清算双写老新
	* 清算单写老和新
	* 清算单写新
* 其他
	* 老结算切一部分到新支付
	* 单写老和新时加锁互查
	* 对外汇总金额
	* 老转发请求到新
	* 写新老表由配置驱动 dao 层切换

成长
* 独立负责单一领域核心服务的重构全流程，梳理掌握理财清结算全业务
* 重构里程碑多，需要协调、考虑各方资源
* 对资金服务的各种变更需要有完整、规范的流程来避免问题发生

技术点
* 反射解析文件
	* 具体的文件解析器持有文件行 model 的泛型类
	* 泛型类的构造方法入参是文件行 String
	* 父类逐行读取文件内容后直接通过 class.newInstance 构建文件 model 实体类
	* 整个循环读一行处理一行
	* 统计行数和金额 & 读取过程中如果有与配置相同的结束符则放入 TL
	* 行数、金额、结束符 check 不过则抛异常
* 线程池监控
	* 线程池放入 map
	* Spring 定时任务根据 cron 的配置从 map 中拿出线程池打印参数到单独的日志
	* 运维平台配置规则解析日志，统计参数
*  线程池动态调参
	* 线程池放入 map
	* apollo 配置中心支持服务监听配置修改事件
	* 监听到线程池参数配置修改后从 map 中获取对应线程池并设置新的参数
* Spring 消息机制解耦一清二清
	* 一清结果请求下游前触发二清
	* 根据数据业务类型从业务工厂拿到 event
	* publish event
	* @EventListener 监听事件
	* 监听事件构建数据落库前方法加锁做幂等判断防止一清结果请求下游失败
* 迭代聚合
	* 文件需要根据 db 中某日所有数据按多维度聚合出 n 条数据
	* 每页捞 500 条聚合一条中间数据
	* 下一页捞出 500 条再聚合成一条中间数据
	* 中间数据再次聚合，最大程度减少内存中数据占用
* 树形结构多维度拦截器
	* 配置为 json 格式，operator & left & right，可以多层嵌套
		* {operator: and, left:{userId:xxx},right:{operator:or,left:xxx,right:{orderNo:xxx}}}
	* 有生效开关配置，必须在开关 ON 时才启用，开关实时读取配置
	* 配置的 key 拼入批次号，第一次构建拦截树后以批次号存入本地缓存
		* curl 接口刷新
		* 默认 24h 
	* 构建
		* 有 operator key，则递归调用构建方法获取 left 和 right key 构建左右节点，节点类型为 OperatorNode 并返回
		* 否则构建 ConditionNode，存放各种维度数据的 Set，配置中的白名单数据直接读进 Set 中
		* 判断时调用两个节点的公共方法 getResult
			* ConditonNode 的此方法是根据数据字段是否在对应 Set 中
			* OperatorNode 的此方法是 left.getResult && right.getResult 或者 left.getResult || right.getResult
* redis 线程可重入锁
	* 加锁
		* 从 TL 中取出 map，根据 key 获取次数
		* 如果次数是 0
			* setNx 放入 key & value & 过期时间
			* 加锁成功次数 +1，返回 true
			* 加锁失败则 map 中删掉此 kv，并返回 false，业务抛异常
		* 如果次数不是 0
			* 次数 + 1，返回 true
	* 解锁
		* 从 TL 中取出 map，根据 key 获取次数
		* 次数为 1
			* 删掉 redis 的 key
			* redis 操作成功则删掉 map 的 kv，返回 true
			* 否则返回 false，，业务抛异常
		* 次数大于 1
			* 次数 -1，返回 true

线上问题
* 退款补单每次只有一笔补单成功
	* 收敛退款接口后，基金子单的退款在 payfront 从付款变成了退款
	* 由于交易请求的是 payment，工作流会导致一笔组合的多笔子单同时向 payfront 发起退款请求
	* 每笔子单需要更新收款单的已退金额，对收款单加锁
	* 代码问题：加锁前开启事务，导致每次补单只有一笔订单能正确的从旧退款金额更新到新退款金额，其他的订单拿到的已退金额均为还没更新的快照版本
* 余额户 500 分
	* [3、资产互转表500分未清零问题排查（RR隔离级别下的脏读） (duxiaoman-int.com)](https://zhishi.duxiaoman-int.com/knowledge/HFVrC7hq1Q/eyzDp1Jx9p/7Gz5kQ4LYp/shCpvgbC8sjRtG)
		* 分布式锁内有事务，但走了内部调用未生效
		* 用了spring event 中的 after commit，spring 自动开了新事务
		* 以上两点导致出现了事务在锁外边的情况
* 引入 fifa 导致流程引擎不开启
	* [20220601-引入 fifa 导致流程不开启 (duxiaoman-int.com)](https://zhishi.duxiaoman-int.com/knowledge/HFVrC7hq1Q/eyzDp1Jx9p/Zc41lh8kjF/ZFw3eReyp9mlm1)
* 慢查
```
explain  
select *  
from pay_settle.sales_settle_detail  
where report_date = '20240116'  
  and direction = 1  
  and clear_ta_code = '01'  
  and serial_no > ''
order by serial_no  
limit 10;
```

| | |
| :- | :- |
| **id** | 1 |
| **select\_type** | SIMPLE |
| **table** | sales\_settle\_detail |
| **partitions** | null |
| **type** | ref |
| **possible\_keys** | idx\_report\_date\_direction\_ta,idx\_report\_date\_direction\_fund |
| **key** | idx\_report\_date\_direction\_ta |
| **key\_len** | 133 |
| **ref** | const,const,const |
| **rows** | 1 |
| **filtered** | 100 |
| **Extra** | Using index condition; Using where; Using filesort |
```
explain  
select min(serial_no)  
from pay_settle.sales_settle_detail  
where report_date = '20240116'  
  and direction = 1  
  and clear_ta_code = '01';
```
| | |
| :- | :- |
| **id** | 1 |
| **select\_type** | SIMPLE |
| **table** | sales\_settle\_detail |
| **partitions** | null |
| **type** | ref |
| **possible\_keys** | idx\_report\_date\_direction\_ta,idx\_report\_date\_direction\_fund |
| **key** | idx\_report\_date\_direction\_ta |
| **key\_len** | 133 |
| **ref** | const,const,const |
| **rows** | 1 |
| **filtered** | 100 |
| **Extra** | null |

* 猜测一：找最小值是回表后维护小顶堆即可，但是 order by limit 会走 filesort（内存或磁盘排序），此 case 下堆排序比 filesort 快
* 猜测二：走了索引合并，因为 serial 联合索引查出来的都是有序的 id，可以直接求 id 交集，但是 serial>'' 拿到的 id 过多，所以比较耗时，而后续 serial_no 有值的 sql 就执行的快多了

