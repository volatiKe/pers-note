一面

leetcode 相交链表

金融场景 float & double 存放金额会有问题吗？应该怎么处理？
	* 不是所有小数都可以变层二进制表示，所以浮点数是近似值
重写 equals 为什么要重写 hashcode
hashmap 两个对象 equals 相同，hashcode 不同会怎么样
	* 散列到不同位置，拿出来的 value 会不同
	* 散列到同一个位置，value 被覆盖
1.7 & 1.8 hashmap 的 put 的差异
	* 头插 和 尾插
	* 加入了红黑树
arrayList & linkedList
	* 添加元哪个更快？看如何定位到插入位置，arrayList 还涉及到扩容
fail-fast
两个链表去重，时间复杂度？两层循环：m * n

```
public int check(User user) {
    try {
        checkUserName(user);
        checkUserAge(user);
        return 0;
    } catch (Throwable e) {
     throw new RuntimeException(e);
    } catch (Exception e) {
        e.printStackTrace();
    } catch (NullPoinerException e) {
        log.error("user error")
    } finally {
        doLog();
        return 1;
    }
}
```

return 1

jvm 怎么处理异常？
	* 异常向量表

```
List<? extends Number> extendList = new ArrayList<>();
List<? super Number> superList = new ArrayList<>();
```

PECS原则

```
List<Integer> intList = new ArrayList<>();
intList.add(1);
List objList = intList;
// 泛型擦除
objList.add(new Object());
intList.get(1);
Object object = intList.get(1);
Integer temp = intList.get(1);
```


public class Cache<K, V> {
  int maxSize;
  Loader<K,V> loader;
  private Map<K,V> map = new HashMap<>();
  private LinkedList<K> list = new LinkedList();
  
  public Cache(int maxSize, Loader<K, V> loader) {
    this.maxSize= maxSize;
    this.loader = loader;
  }
  
  public V get(K key) {
    if(map.get(key)!=null){
      list.remove(key);
      list.add(key);
      return map.get(key);
    }else{
      V val = loader.load(key);
      put(key,val);
    }
  }
  
  private void put(K key,V val){
    if(map.containsKey(key)){
      map.put(key,val);
      list.remove(key);
      list.add(key);
    }else if(list.size()==maxSize){
      Key lastKey = list.removeLast();
      map.remove(lastKey);
      map.put(key,val);
      list.add(key);
    }else{
      map.put(key,val);
      list.add(key);
    }
  }
}


public interface Loader<K, V> {
  V load(K key);
}

要求基于LRU实现一个缓存

要求如下

1. cache 的最大容量不超过maxSize
2. 一旦超过maxSize，那么基于LRU逐出元素
3. 使用泛型实现
4. 对外提供的只有一个get方法，并且对于任意给定的key，一定会需要返回对应的value。
5. 如果缓存中不存在给定的key时，则可使用loader 进行初始化给定key的value值，loader不是存储数据的结构，只用于初始化key对应的value
6. 需要什么样的数据结构自行添加

延伸：
O1 时间复杂度
线程安全问题，改成线程安全容器行吗？