一面

equals & hashCode 互相的依赖关系，hashmap 的 put、get 流程
装载因子，作用是啥
	扩容系数，0.75 平衡了时间和空间
线程池什么时候会新建线程
线程安全问题发生的根本原因
	工作内存和主内存数据不一致，线程并发执行操作成员变量时拿到的值可能还不是最新的值
用过哪些设计模式
	* 命令模式
索引失效场景
覆盖索引
mysql 默认隔离级别
	* rr 解决了什么问题
	* 如何实现 rr
	* rr下能不能读取最新数据
缓存一致性问题
	* 第二次删除失败，如何补偿
	* 如何保证 mq 消息一定发送成功
		* 先写表还是先发消息：先写 + 状态机
		* 写消息和更新数据库需要在一个事务

二面

既然时间计算更重要，那么如何保证按序流转资金？
* CT + 监控
* 部分节点人工触发，人工的触发等通知
* 在线服务 + 监控
用到的技术
* 文件的处理：反射、线程池批处理
* 锁：分布式锁
* 业务的衔接：spring 的事件机制
* 回调代替了消息队列
* RPC

一致性 hash
如何实现一个带过期功能的缓存

惰性删除：
* map：value 除了值外需要设置存入时间
* get 时如果当前时间减去过期时长大于存入时间，则失效

定期删除：
基于循环队列的定时器
* 队列长度是时间精度：如秒精度则为 60
* 根据过期时长，将该kv 放在 对应位置上（根据当前时间算出圈数+位置）
* 每扫一圈圈数减1，圈数为0后再次扫到即置为失效

场景：
10W 支股票，不停的有股票涨跌幅的数据推送，每支股票推送数据的频率不同，实时展示涨跌幅 top 10 的股票信息 

* redis zset
	* 限流限制更新 redis 数据的频率
		* 限流算法
	* 一次修改的数据量大，可能超过 redis  的理论负载
		* 分片存储，展示的时候从每个分片拿 10 个
	* 如何降低更新的次数？
		* 根据不同的推送频率分类，降低某些分片的写数据次数
* 堆
	* 堆大小就是 10，堆中就是局部（1s刷新一次，局部就是1s内推送了数据的股票的top 10）的 top 10 的数据，不断的刷新这个堆
	* 两个股票，涨跌幅一致
		* 在堆中占两个位置
	* 一个股票涨跌交替，导致堆中都是这个股票
		* 不希望这种情况出现，应该是展示 10 个不同的股票
		* 需要去重，堆中存在的更新
			* 如何去重
			* 不存在的如果堆中已经有10个元素，则和堆顶比较 & 替换
			* 不到 10 个就直接扔进去

旋转数组的二分查找