以下均基于 InnoDB

# 行锁

* Record Locks
	* 区分读写锁
	* 锁范围：单条记录
	* 读写锁存在互斥性
* Gap Locks
	* 不区分读写锁
	* 锁范围：( 上一条记录，加锁记录 )
	* 不存在互斥性，多个事务可持有包含共同间隙的 Gap Locks
* Next-Key Locks
	* 区分读写锁
	* 锁范围：( 上一条记录，加锁记录 ]
	* 由于也锁了记录，所以读写存在互斥性
* Insert Intetion Locks
	* insert 时如果插入位置存在 Gap Locks，则生成一个 Insert Intention Locks，表示想在某个区间的某点插入记录，但处于等待状态
	* 与 Gap Locks 互斥

# CRUD 加锁

* 普通 select
	* RC & RR：走 MVCC，读取到的数据不保证最新，不会被阻塞
	* RU：直接读最新记录，不会被阻塞
	* S：
		* 不允许自动提交：加读锁
		* 允许自动提交：直接利用 MVCC 生成 ReadView 进行读取

> 自动提交：每个事务中只有一条语句

* 加锁 select
	* 见后文
* delete
	* 定位并执行 delete mark（定位的过程和加锁 select 一致）
* update
	* 可以简单看成 delete + insert
* insert
	* 隐式锁机制保证其他事务无法读写当前事务 insert 的记录
	* 特殊情况会出现显示锁
		* 存在 Gap Locks，会生成 Insert Intension Locks
		* 唯一键冲突

> 隐式锁：事务中可以不对新插入的记录显示加锁，也能保证这条新的记录不会被其他事务读写，是因为记录的隐藏列持有事务 ID 字段，记录了当前插入数据的事务，其他事务想对此记录加锁时，会判断此事务 ID 是否为活跃事务，如果是则帮助该活跃事务创建锁，自己进入等待状态

# 锁定读加锁

RR 下：

* 加锁对象：索引
* 锁基本单位：Next-Key Locks
* 锁的退化：在能使用 Record Locks 或 Gap Locks 就能避免幻读问题的情况下，Next-Key Locks 会退化为对应的锁

需要注意的是：如果加锁读、update、delete 的查询条件没有走索引，即相当于全表扫描，扫描过程中会对索引加锁，相当于对每一行记录加 Next-Key Locks，相当于锁表