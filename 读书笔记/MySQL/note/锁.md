## 锁的分类

### 行锁

* Record Locks
	* RC 及以上存在
	* 区分读写锁
	* 锁范围：单条记录
	* 读写锁互斥
* Gap Locks
	* RR 存在
	* 不区分读写锁
	* 锁范围：( 上一条记录，加锁记录 )
	* 不互斥，多个事务可持有包含共同间隙的 Gap Locks
* Next-Key Locks
	* RR 存在
	* 区分读写锁
	* 锁范围：( 上一条记录，加锁记录 ]
	* 读写锁互斥，因为也锁了记录
* Insert Intention Locks
	* 自身之间不互斥，与 Gap Locks 和 Next-Key Locks 互斥
	* insert 时如果插入位置存在 Gap Locks，则生成一个 Insert Intention Locks，表示想在某个区间的某点插入记录，但当前 insert 的事务并未获取锁，事务阻塞，直到 Gap Locks 释放，insert 事务成功获取 Insert Intetion Locks
	

## CRUD 加锁

* 加锁 select、delete、update
	* 行锁
* insert
	* 显式锁
		* 存在 Gap Locks，会生成 Insert Intension Locks
		* 唯一键冲突
	* 隐式锁：
		* 事务中不对新插入的记录显式加锁，也能保证这条新的记录不会被其他事务读写，是因为记录的隐藏列事务 ID 记录了当前插入数据的事务，其他事务想对此记录加锁时，会判断此事务 ID 是否为活跃事务，如果是则帮助该活跃事务创建锁，自己进入等待获取锁的状态


## 加锁原理
### 加锁粒度

* 加锁的基本单位是 next-key locks
	* 如果加锁 select、update、delete 的查询条件没有走索引，即相当于全表扫描，扫描过程中会对索引加锁，相当于对每一行记录加 Next-Key Locks，相当于锁表

### 加锁原则

* 查找过程中访问到的数据（符合条件的数据）都会加锁
	* 加锁的对象是索引，如果使用二级索引进行锁定读时，除了会对二级索引项加锁，还会对查询到的数据的一级索引上加 Record Locks

### 加锁优化

* 唯一索引等值查询时会退化为 record locks
* 等值查询时从查询条件向右遍历且最后一个值不满足条件会退化为 gap locks

### 加锁对象查找原则

* 唯一索引的范围查询会访问到不满足条件的第一个值为止
* 非唯一索引的等值查询、范围查询均会访问到不满足条件的第一个值为止

### case 分析

表：id, a, b
非唯一索引：a
主键：id
数据：
(0,0,0),(5,5,5),(10,10,10),(15,15,15),(20,20,20),(25,25,25)

```sql
select * from t where id=7 for update;
```
* 根据加锁原则，锁为 id-(5,10]
* 根据优化 2，退化为 gap locks：id-(5,10)

```sql
select id from t where a=5 lock in share mode;
```
* 根据加锁原则，锁为 a-(0,5]
* 根据查找原则 2 和加锁原则，锁还有 a-(5,10]
* 根据优化 2，a-(5,10] 退化为 (5,10)
* 根据加锁原则，此查询使用覆盖索引，所以一级索引上无锁

```sql
select * from t where id>=10 and id<11 for update;
```
* 此查询可以看成两部分：id=10、id>10 & id<11
* 根据加锁原则和优化 1，id=10 锁为 id-10
* 根据查找原则 1 和加锁原则，id 的范围查找锁还有 id-(10,15]

```sql
select * from t where a>=10 and a<11 for update;
```
* 此查询可以看成两部分：a=10、a>10 & a<11
* 根据加锁原则，a=10 锁为 a-(5,10]
* 根据查找原则 2 和加锁原则 ，a 的范围查找还有锁 a-(10,15]
* 根据加锁原则，此查询需要回表，所以一级索引有锁

```sql
select * from t where id>10 and id<=15 for update;
```
* 此查询可以看成两部分：id=15、id>10 & id<15
* 根据加锁原则，id=15 锁为 id-(10,15]
* 根据查找原则 1 和加锁原则，id 的范围查找锁还有 id-(15,20]