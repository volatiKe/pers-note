## 锁的分类

### 行锁

* Record Locks
	* RC 及以上存在
	* 区分读写锁
	* 锁范围：单条记录
	* 读写锁互斥
* Gap Locks
	* RR 存在
	* 不区分读写锁
	* 锁范围：( 上一条记录，加锁记录 )
	* 不互斥，多个事务可持有包含共同间隙的 Gap Locks
* Next-Key Locks
	* RR 存在
	* 区分读写锁
	* 锁范围：( 上一条记录，加锁记录 ]
	* 读写锁互斥，因为也锁了记录
* Insert Intention Locks
	* 自身之间不互斥，与 Gap Locks 和 Next-Key Locks 互斥
	* insert 时如果插入位置存在 Gap Locks，则生成一个 Insert Intention Locks，表示想在某个区间的某点插入记录，但当前 insert 的事务并未获取锁，事务阻塞，直到 Gap Locks 释放，insert 事务成功获取 Insert Intetion Locks
	

## CRUD 加锁

* 加锁 select、delete、update
	* 行锁
* insert
	* 显式锁
		* 存在 Gap Locks，会生成 Insert Intension Locks
		* 唯一键冲突
	* 隐式锁：
		* 事务中不对新插入的记录显式加锁，也能保证这条新的记录不会被其他事务读写，是因为记录的隐藏列事务 ID 记录了当前插入数据的事务，其他事务想对此记录加锁时，会判断此事务 ID 是否为活跃事务，如果是则帮助该活跃事务创建锁，自己进入等待获取锁的状态


## 加锁原理

### 加锁原则

* 加锁的基本单位是 next-key locks
	* 如果加锁 select、update、delete 的查询条件没有走索引，即相当于全表扫描，扫描过程中会对索引加锁，相当于对每一行记录加 Next-Key Locks，相当于锁表
* 查找过程中访问到的数据（符合条件的数据）都会加锁

### 加锁对象

* 加锁的对象是索引
	* 如果使用二级索引进行锁定读时，除了会对二级索引项加锁，还会对查询到的数据的一级索引上加 Record Locks

### 加锁优化

* const 查询时会退化为 record locks
* const、ref 查询时查不到记录会退化为 gap locks
	* 从查询条件向右遍历且最后一个值不满足条件

* 加锁对象：索引

> 需要注意的是，

* 加锁基本单位：Next-Key Locks

> 需要注意的是，


# 唯一索引等值查询

* 记录存在：退化为 Record Locks
* 记录不存在：退化为 Gap Locks，找到第一条唯一索引值大于条件值的记录为右边界值，该记录的上一条为左边界值

# 唯一索引范围查询

