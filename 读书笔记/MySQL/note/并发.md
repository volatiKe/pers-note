以下均基于 InnoDB

# 隔离级别

隔离级别由 SQL 标准规定，代表了事务并发执行和隔离性之间的取舍程度，，四个隔离级别依次防止以下问题及更低隔离级别防止的问题：

* 脏写
* 脏读
* 不可重复读
* 幻读

不同 DB 厂商对隔离级别的支持与实现不同，如 MySQL 在 RR 级别下可较大程度上防止幻读发生

> 对于先前可读到的记录，之后又读不到的情况，不认为是幻读，而是读不到的每一条记录都发生了不可重复读。而幻读强调的是读到了之前没有读到的记录

# MVCC

## 版本链

[[数据存储#行（记录）|行数据]]在 MySQL 的存储结构中保留了以下字段：

* 事务 ID：每次一个事务对聚簇索引中的行数据就行修改时，都会把当前事务 ID 分配给该条记录的此字段
* 回滚指针：每次一个事务对聚簇索引中的行数据进行修改时，都会把该记录的当前值（**包括事务 ID**）写到 undo log 中，此字段的值指向该条记录 undo log 中上一个版本的值的位置，而 undo log 中旧版本的数据也会再指向 log 中再上一个版本值的位置
	* insert 操作时此字段无有效值

回滚指针将聚簇索引和 undo log 中的数据组成了一个链表，记录了数据的修改历史，即版本链

## ReadView

用来判定「所读数据的版本链中，哪一个版本的数据对当前事务是可见的」

## MVCC

**MVCC 就是在执行普通 select 时访问版本链的过程**，而根据执行普通 select 时 ReadView 的生成机制不同，MVCC 可解决以下读写并发问题：

* 脏读：事务中的每次查询都生成新的 ReadView，即每次 ReadView 中的参数随着其他并发事务陆续提交而发生变化，从而导致对版本链中可读版本数据的判定发生变化
* 不可重复读 & 幻读：事务中的每次查询都使用第一次查询时生成的 ReadView，即只要当前事务不提交，ReadView 中的参数就不会变化，从而使得每次查询对版本链中可读版本数据的判定都不会变

# 锁

加锁是另外一种解决读写并发问题的方式

* 脏读：写记录时对该记录加写锁，其他事务无法读该记录，即不会读取到已更新且未提交的记录
* 不可重复读：读记录时对该记录加读锁，其他事务无法写该记录，即加读锁的事务内读取的结果始终一致
* 幻读：读记录时在范围内加间隙锁（读间隙锁和写间隙锁效果一致），其他事物无法在此范围内 insert 记录

# 隔离级别的实现

首先，**所有隔离级别下均需要加锁保证写操作串行化执行，防止写并发**

* RU
	* 不考虑读写并发，直接读取最新记录
* RC
	* 写时加锁保证不可读，避免脏读
	* 基于 MVCC 的快照读，避免脏读
* RR
	* 写时加锁保证不可读，避免脏读
	* 读时加锁保证不可写或新增，避免不可重复读和幻读
	* 基于 MVCC 的快照读，避免不可重复读和幻读
* S
	* 所有操作加锁