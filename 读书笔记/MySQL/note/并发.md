以下均基于 InnoDB

# 事务

访问、操作数据项的数据库操作序列集合

**原子性**（Atomicity）：作为一个整体执行，要么都成功，要么都失败
**一致性**（Consistency）：无论事务执行成功与否，数据库都会处在一个一致的状态。
**隔离性**（Isolation）：各个事务在执行过程中互不影响
**持久性**（Durability）：事务执行成功后对数据的修改永久保存

如何理解事务的 ACID 特性：

* 一致性是结果正确的必要条件
* 无并发时，满足原子性就能保证一致性
* 有并发时，原子性 + 隔离性才能保证一致性
* 持久性是为了应对 db 崩溃的 case

# 并发问题

* 脏写
* 脏读
* 不可重复读
* 幻读
# 隔离级别

隔离级别由 SQL-92 标准规定，代表了事务并发执行和隔离性之间的取舍程度，四个隔离级别依次防止以下问题及更低隔离级别防止的问题：

* Read Uncommitted：脏写
* Read Committed：脏读
* Repeatable Reads：不可重复读
* Serializable：幻读

不同 DB 厂商对隔离级别的支持与实现不同，如 MySQL 在 RR 级别下可较大程度上防止幻读发生

> 对于先前可读到的记录，之后又读不到的情况，不认为是幻读，而是读不到的每一条记录都发生了不可重复读。而幻读强调的是读到了之前没有读到的记录

# 隔离级别下并发问题的解决

## 机制：MVCC

### 版本链

[[数据存储#行（记录）|行数据]]在 MySQL 的存储结构中保留了以下字段：

* 事务 ID：每次一个事务对聚簇索引中的行数据就行修改时，都会把当前事务 ID 分配给该条记录的此字段
* 回滚指针：每次一个事务对聚簇索引中的行数据进行修改时，都会把该记录的当前值（**包括事务 ID**）写到 undo log 中，此字段的值指向该条记录 undo log 中上一个版本的值的位置，而 undo log 中旧版本的数据也会再指向 log 中再上一个版本值的位置
	* insert 操作时此字段无有效值

回滚指针将聚簇索引和 undo log 中的数据组成了一个链表，记录了数据的修改历史，即版本链

### ReadView

用来判定「所读数据的版本链中，哪一个版本的数据对当前事务是可见的」

### MVCC

**执行普通 select 时就是借助 MVCC 机制访问版本链的过程**，而根据执行普通 select 时 ReadView 的生成机制不同，MVCC 可解决以下读写并发问题：

* 避免脏读：事务中的每次查询都生成新的 ReadView，即每次 ReadView 中的参数随着其他并发事务陆续提交而发生变化，从而导致对版本链中可读版本数据的判定发生变化
* 避免不可重复读 & 幻读：事务中的每次查询都使用第一次查询时生成的 ReadView，即只要当前事务不提交，ReadView 中的参数就不会变化，从而使得每次查询对版本链中可读版本数据的判定都不会变

> 需要明确的是，不管是一个事务读另一个事务正在写的记录，还是一个事务写另一个事务正在读的记录，写操作的对象是版本链上处于头节点的最新版本，而读操作读取的是历史版本，这种方式在 RU、RC、RR 下都不会产生矛盾

## 机制：LBCC

加锁是另外一种解决读写并发问题的方式

### 行锁

* Record Locks
	* RC 及以上存在
	* 区分读写锁
	* 锁范围：单条记录
	* 读写锁互斥
* Gap Locks
	* RR 存在
	* 不区分读写锁
	* 锁范围：( 上一条记录，加锁记录 )
	* 不互斥，多个事务可持有包含共同间隙的 Gap Locks
* Next-Key Locks
	* RR 存在
	* 区分读写锁
	* 锁范围：( 上一条记录，加锁记录 ]
	* 读写锁互斥，因为也锁了记录
* Insert Intention Locks
	* insert 时如果插入位置存在 Gap Locks，则生成一个 Insert Intention Locks，表示想在某个区间的某点插入记录，但锁处于等待状态，使得 insert 的事务发生阻塞，直到 Gap Locks 释放，insert 事务成功获取 Insert Intetion Locks

### CRUD 加锁

* 加锁 select、delete、update
	* [[锁定读加锁机制]]
* insert
	* 隐式锁机制保证其他事务无法读写当前事务 insert 的记录
	* 特殊情况会出现显式锁
		* 存在 Gap Locks，会生成 Insert Intension Locks
		* 唯一键冲突

> 隐式锁：事务中不对新插入的记录显式加锁，也能保证这条新的记录不会被其他事务读写，是因为记录的隐藏列持有事务 ID 字段，记录了当前插入数据的事务，其他事务想对此记录加锁时，会判断此事务 ID 是否为活跃事务，如果是则帮助该活跃事务创建锁，自己进入等待状态

## 并发问题的解决

首先，**所有隔离级别下均需要加锁保证写操作串行化执行，防止写并发**

### 读使用 MVCC 写加锁

* RU
	* 写加锁防止并发写
	* 不考虑读写并发，直接读取最新记录
* RC
	* 写加锁防止并发写
	* 基于 MVCC 的快照读，避免脏读
* RR
	* 写加锁防止并发写
	* 基于 MVCC 的快照读，避免不可重复读和幻读
* S
	* 所有操作加锁
### 读写加锁

* RU
	* 写记录时加写锁，其他事务无法读写，事务结束释放
* RC
	* 写记录时加写锁，其他事务无法读写，事务结束释放
	* 读记录时加读锁，其他事务无法写，读完释放，即不会读取到已更新且未提交的记录
* RR
	* 写记录时加写锁，其他事务无法读写，事务结束释放
	* 读记录时加读锁，其他事务无法写，事务结束释放，即事务内读取到的结果一致
	* 如果还要避免幻读，则需要读记录时加 Gap Locks，其他事务无法在此范围内 insert 记录

> MySQL InnoDB 在 RR 下无法完全避免幻读
> 如在当前事务去 update 其他事务 insert 的数据的可以成功的，或事务内先快照读后锁定读

* S
	* 所有操作加锁

可以看到，不管是 LBCC 还是 MVCC 都可以实现四种隔离级别，但是 MVCC 的优势在于实现了读写并行，相比 LBCC 提高了并发度