MySQL 的存储行为基于存储引擎实现，以下均基于 InnoDB

## 行（row）

表中每一行数据是按行且遵循某种行格式进行存放的

### InnoDB 默认行格式

Compact：
* 额外信息：
	* 变长字段长度列表：记录如 varchar 类型字段的长度
	* NULL 值列表：以二进制 bit 的形式记录哪些列为 NULL
	数据：
	* row_id：行 ID，记录唯一标识，没有自定义主键及唯一索引时才存在
	* transaction_id：事务 ID
	* roll_pointer：上一个版本数据的指针

## 页（page）

* 磁盘和内存交换数据的基本单位
* 管理存储的基本单位
* 默认页大小为 16KB

### 数据页

行在每页中：
* 逻辑上按照主键的升序构成一个单向链表
* 每条记录存有到逻辑上下一条记录的地址偏移量

#### 页目录（page directory）

为了提升页中行的查找速度，页中的数据会分组，并将每组最后一条数据的地址偏移量记录在 page directory 中，标记为一个 slot

#### 页中查询行

当查询页中记录时，可以使用二分法定位待查找记录在哪个 slot 中，再遍历当前组的记录即可

#### 页头（page header）

包含：
* 该页记录的条数
* 第一条数据的地址
* 校验和

#### 文件头（file header）

包含：
* 页号：InnoDB 通过页号定位页的位置
* 上一页页号 & 下一页页号：让页形成双向链表

#### 页尾（file trailer）

作用：用来检测页是否完整，包含：
* 校验和：和页头的对应，当在内存中将页修改后需要刷新回磁盘时，需要先计算新的校验和，页头处于页中记录的前边部分，所以会先将新的校验和刷新到磁盘，如果更新记录过程中断电等，那么页尾的校验和和页头不一致，就知道当前页同步出现异常
* LSN：页面被最后修改时对应的日志序列的位置
	* redo log 和数据页都保存着 LSN，可以用作数据恢复的依据。LSN 更大的表示所引用的日志记录所描述的变化发生在更后面

## 区（extend）

InnoDb 按照 B+ 树结构组织索引树，由于其结构的每一层都是按照双向链表将页连接起来，逻辑上是连续的结构。为了物理上也形成连续的结构，会在为索引分配空间时按照区（1MB）来分配，每个区内的页在物理地址上都是连续的