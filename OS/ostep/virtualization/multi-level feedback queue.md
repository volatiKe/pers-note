# 多级反馈队列

## 引入

MLFQ 试图解决两方面问题：

* 优化周转时间：虽然可以通过 SJF 或 STCF 实现，但 OS 无法得得知任务运行时间
* 优化响应时间：虽然可以通过 RR 实现，但会增加周转时间

## 基本规则

形式：

* 拥有多个队列
* 每个队列有不同的优先级
* 任一给定时间，一个任务只处于一个队列中

基本规则：

* 规则 1：if priority(A) > priority(B), A runs
* 规则 2：if priority(A) = priority(B), A & B run in RR

MLFQ 执行调度的关键是如何设置任务的优先级：MLFQ 会根据任务表现出的行为动态调整其优先级，如：

* 任务频繁的释放 CPU 资源、等待键盘输入，如果这是交互型进程的行为，为了良好的交互体验，将其保持在高优先级
* 任务长时间占用 CPU 资源，则降低其优先级

## 优先级调整

考虑如下场景：

* 可能频繁放弃 CPU 资源的一堆短时间运行的交互型任务
* 一些长时间运行的、不关心响应时间的计算密集型任务

优先级调整规则：

* 规则 3：当任务到达时，给予最高优先级
* 规则 4a：如果任务在运行期间使用了一个完整的时间片，则降低其优先级
* 规则 4b：如果在一个时间片结束之前释放了 CPU 资源，则优先级不变

问题：

* 饥饿：太多的交互式任务会一直占用 CPU 资源导致其他低优先级的任务始终无法获取 CPU 资源
* 调度漏洞：如利用规则 4b，在时间片结束之前，故意发起一个 I/O 请求，主动释放 CPU，重复此操作，可以使进程始终保持高优先级

## 优先级提升

为了避免饥饿，最简单的方法就是提升任务的优先级：

优先级提升规则：

* 规则 5：在时间 S 后，将所有任务移动至最高优先级队列

问题：

S 的取值？如果太高，需要长时间运行的任务会出现饥饿；如果太低，交互型的任务无法适当地获取 CPU 资源

## 更好的计时方式

可以看出，调度漏洞问题的元凶是规则 4a & 4b 的时间片计时方式，所以考虑改变对 CPU 资源占用的衡量标准：

* 规则 4：任务一旦在某个优先级队列中用尽了其被分配的 CPU 时间（无论主动放弃 CPU 多少次），就降低其优先级

## MLFQ 调优

* 大多数 MLFQ 都支持在不同优先级队列下配置不同的时间片长短：
	* 高优先级使用较短的时间分片，可以更好的支持交互型任务（需要更快地切换）
	* 低优先级使用较长的时间分片，因为更多的是计算密集型任务
* 其他特性：
	* 有的 MLFQ 的实现中，最高优先级队列只供 OS 使用
	* 有的允许用户给出优先级建议，调度时会根据用户设置的建议进行优先级调整