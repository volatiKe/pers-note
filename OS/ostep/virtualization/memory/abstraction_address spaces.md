# Abstraction : Address Spaces

## 早期系统

OS 和用户程序各占用一部分内存，并没有地址空间的抽象
![[img/address spaces/Pasted image 20220518095211.png]]

## 多道程序 & 时分共享

* 希望更有效地使用机器，出现了多道程序：多个进程一起运行，加上时分共享的出现，使得通过切换进程的方式来提高程序运行效率
* 但在切换程序时，需要将上下文保存起来（磁盘），使得当前运行的进程使用全部的内存空间
* 如果只是保存寄存器相关数据还好，但要将上一个进程的全部内存信息保存在磁盘上，效率十分低下，所以之后开始将进程信息仍然放在内存中，每个进程拥有内存空间的一部分
* 既然多个进程的数据都在内存中了，那么各个进程间数据的安全性又成了一个问题
![[img/address spaces/Pasted image 20220518100130.png]]

## 地址空间

* 为了解决各种内存使用的问题，OS 需要提供一个易于使用的物理内存抽象，即地址空间
* 一个进程的地址空间包含了运行的程序的所有内存状态，这里简化内存模型：包含代码、栈、堆：
	* 代码从 0 开始，因为存储代码所需要的空间是确定的
	* 堆和栈的空间不确定，可能增长也可能降低，所以置于剩余空间的两端，向内增长
![[img/address spaces/Pasted image 20220523200219.png]]
需要明确的是：我们所说的地址空间只是 OS 为运行的程序提供的一种抽象，并不是从 0 地址开始，真正的分布类似图二的进程 A、B、C。当 OS 这么干时，我们就认为进行了内存虚拟化，因为运行的程序认为它被加载到了 32 位或 64 位、从 0 开始的内存空间。反过来也一样：当进程在 0 地址进行操作时，也必须保证实际使用的是该进程 0 地址对应的物理地址

## 目标

* 虚拟内存对运行的程序是透明的（实现物理内存复用）
* 虚拟内存是高效的（不会使程序变慢，也不需要太多内存支持虚拟化，必要时需要借助额外的硬件）
* 虚拟内存是受保护的（进程、OS 之间使用的内存空间是隔离的）