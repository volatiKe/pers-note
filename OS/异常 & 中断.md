## 异常

异常指 CPU 控制流的突变，当 CPU 检测到事件发生时，通过异常表跳转到处理此异常的异常处理程序

CSAPP 中将异常分为四种：interrupt、trap、fault、abort

* 中断：可以理解成使用外部设备触发的异步事件，微观层面是一种电信号，由硬件设备生成，通过中断处理器（将多个中断线路通过一个线路连接到 CPU 进行通信）传给 CPU，CPU 存在特殊引脚接收该信号
* 其他异常：同步事件，程序错误或内核必须处理的异常条件产出（如内存缺页）

> * 异步是指它的产生时机不一定和 CPU 时钟同步，可能在任意时机出现
> * 同步是指它的产生时机一定和 CPU 时钟同步，只有在 CPU 执行完一条指令后才会发出

## 中断

OS 在处理中断时可能需要关闭对其他中断的响应，所以就要求中断处理时间要尽可能短，Linux 为了解决此问题，将中断处理分为两个阶段

* 硬中断：处理硬件直接产生的中断（即上文提到的异常分类里的中断）
* 软中断：模拟硬中断，用于处理硬中断允许稍后完成的工作。但与硬中断只能通过中断处理程序实现不同，软中断有多种实现方式
 
以网卡为例，当网卡接收到来自网络的数据包时，需要通知内核数据包到了，网卡需要立即完成这件事，从而优化网络的吞吐量和传输周期，避免超时。因此**网卡立即发出中断，内核通过执行网卡注册的中断处理程序来应答。中断开始执行，通知硬件，拷贝最新的网络数据包到内存，然后再去读取网卡更多的数据包**。这些重要且急迫，又与硬件相关的工作都由上半部来完成。内核通常需要快速的拷贝网络数据包到系统内存，**因为网卡上接收网络数据包的缓存大小固定，而且相比系统内存也要小得多。所以如果拷贝的动作延迟了，必然会导致缓存溢出，进入的网络包占满了网卡的缓存，后续到来的网络包只能被丢弃**。当网络数据包被拷贝到系统内存后，中断的任务就完成了，此时它将控制权还给系统被中断前原先运行的程序，处理和操作数据包的工作都在随后的下半部来完成

> 产生中断的每个设备都有一个相应的中断处理程序，包含在该设备的**驱动程序**中

## 高层异常形式：系统调用

1. 应用程序调用系统函数，该函数是一个包装系统调用的**库函数** 
2. **库函数**负责准备向内核传递的参数，并触发 **trap 异常**以切换到内核态
3. CPU 被打断后，执行**异常处理函数** ，即**系统调用处理函数**

## 高层异常形式：上下文切换

* 当发生系统调用时需要保存当前线程执行的上下文，以便在切回用户态时继续执行下一条指令
* 当发生时钟中断时，OS 可以重获 CPU 控制权从而进行线程调度，需要保存当前线程执行的上下文以便下一次执行