# GC

---

## 1. 对象存活判定

**引用计数**：记录对象被引用的次数，计数为 0 时表示对象可被回收，但当两个对象互相引用而无其他引用时此方法失效。

**可达性分析**：选定某些对象作为 GC Roots，从这些对象出发进行搜索引用，如果 GC Roots 到一个对象不可达时则认为这个对象可被回收

* GC Roots 的选择：**栈帧中局部变量引用的对象**、**方法区中静态变量引用的对象**、**方法区中常量引用的对象**，可以认为这些对象以及相关的对象正在被使用，那么其他不相关的对象则可以被回收
* Stop-The-World：JVM 在寻找 GC Roots 时为了保证各个对象的引用状态不发生变化，需要停止所有 Java 线程

## 2. 引用类型

**强引用**：永远不会被 GC 即使内存不足。

**软引用**：内存溢出之前将这些对象列入回收范围中进行第二次 GC。

**弱引用**：当一个对象只剩弱引用指向它时，下一次 GC 一定会被回收。

**虚引用**：无法获取实例，也不影响生存时间，在对象被 GC 时会收到通知。

## 3. GC 算法

标记-清除（Mark-Sweep）：标记出所有需要回收的对象后统一清理，但是这种算法效率不高，而且会产生大量不连续的内存碎片。

停止-拷贝（Stop-Copy）：将内存分为两部分，每次只使用一块，当一块内存用完时将存活的对象复制到令一块内存，将使用过的空间一次性清空。这种算法的好处是效率高而且不会产生内存碎片，但是空间代价过大，在存活对象过多时复制操作会影响效率。

标记-整理（Mark-Compact）：标记出所有需要回收的对象，将它们移动到一侧后再统一清理，避免产生内存碎片。

**分代收集**：根据对象存活时间将**堆内存**划分为若干区域（**年轻代**和**老年代**），不同区域使用不同的 GC 算法：

* 年轻代：分为 Eden / Survivor0 / Survivor1，按 8:1:1 分配。每次使用 Eden 和一块 Survivor，GC 时将 Eden 和这块 Survivor 中存活的对象一次性复制到另一块 Survivor 中，再将其他两个区域清空
* Minor GC：对年轻代的 GC
* Full GC：对老年代的 GC

## 4. 堆内存分配策略

**对象优先分配在 Eden 区**：不够分配时触发 Minor GC。

* -Xms20M：初始堆大小
* -Xmx10M：最大堆大小
* -Xmn10M：年轻代大小
* -XX:SurvivorRatio=n：Eden 与一个 Survivor 区域的比例为 n:1

**大对象直接进入老年代**：需要大量连续空间的对象，如很长的数组。

* -XX:PretenureSizeThreshold=m：大于m的对象直接分配在老年代

**长期存活的对象进入老年代**：对象在 Eden 区被分配并经过一次 Minor GC 后存活，且能被 Survivor 容纳，此时对象年龄为 1，此后每在一次 Minor GC 后存活则年龄加 1，达到一定程度后对象被晋升至老年代。目的是**避免大量的对象在年轻代中的复制**。

* -XX:MaxTenuringThreshold=i：对象进行老年代的年龄阈值
* **动态年龄判定**：Survivor 中同龄对象的总大小大于 1/2 的 Survivor 大小，年龄大于等于该年龄的对象直接进入老年代

**空间分配担保**：在极端情况下，如果 Eden 区所有对象都存活，加上 Survivor 中已有的对象，另一块 Survivor 必然不够容纳，需要老年代进行承担。所以 Minor GC 前需要检查老年代最大连续可用空间是否大于新生代所有对象总大小：

* 条件成立则 GC 是安全的，说明能够担保成功
* 否则查看 HandlePromotionFailure：
  * 若允许担保失败，则检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，若大于则进行 Minor GC，但此次 Minor GC 存在风险
  * 不大于或不允许担保失败则直接进行 Full GC

## 5. G1 垃圾回收器

**空间整合**：将整个堆划分为若干个 Region，分为 Eden / Survivor / Old，全局角度上标记-整理算法应用于每个 Region，而针对每个 Region 之间，使用停止-拷贝算法。两种算法均不会产生内存碎片。

**可预测的停顿**：通过记录每个 Region 的 GC 时间以及 GC 后获得的空间，维护一个优先列表，根据指定的 GC 时间，优先回收价值最大的 Region，保证优先时间内获得尽可能高的回收效率。

GC 过程：

1. 初始标记：标记 GC Roots 直接关联的对象，需要 STW，但耗时很短
2. 并发收集：进行所有对象的可达性分析，耗时较长，但可以用户线程并发执行
3. 最终标记：対并发标记阶段由于并发的用户线程执行而导致可达性变动的部分进行修改，也需要 STW，但是可以利用多个 CPU 并行执行提高效率
4. 筛选回收：対 Region 的回收进行排序，根据指定的 GC 时间回收，需要 STW，但同样能够并行执行
