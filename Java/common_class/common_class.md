# 常用类

---

## 1. Object

### 1.1 equals()

Object 类的此方法比较两个对象地内存地址，效果等同于：

```return (this == obj)```

对于 String / Date / Long / Integer 等会默认重写为比较内存空间的值，其中 Long 的默认重写，还会比较类型

关于「==」：

* 基本类型比较值
* 引用类型比较内存地址，包括包装类
* 包装类与基本数字类型变量或表达式比较时会自动拆箱

### 1.2 hashCode()

对于大量快速的对比 equals() 效率不高，所以需要先用 hashCode() 快速定位，这种场景在一些容器中会涉及到，如 HashMap 等，能够提高比较的性能

为什么重写 equals() 则必须重写 hashCode()：

* 如果基于对象的内容重写了equals()，而保留 hashCode() 不变，那么很可能某两个对象「相等」，但 hashCode 按照默认计算是不等的。这样当用其中的一个作为键保存到容器中，再以「相等」的另一个去查找时会无法找到，因为容器内部会优先比较 hashCode。所以在使用自定义对象作为 Map 的 key 时，需要重写二者

需要注意的是：

「如果元素相同，则 hash 值一定相同」

以及它的逆否命题：

「如果 hash 值不同，则元素一定不同」，这也是为什么布隆过滤器判不存在时不会误判。

## 2. String

### 2.1 常量池

常量池是为了避免频繁地创建和销毁对象而影响系统性能，其实现了**对象的共享**，如String 类维护了一个字符串常量池

编译期常量池：

* 在Class文件中即可以看到，主要用于存放字面量以符号引用
* 常量池中的对象在编译期就已经确定了。但需要注意的是，常量池保存的是已经确定的值，对于String类来讲，就是字面量及字面量的拼接，如果在拼接中出现了变量，则会被编译为StringBuilder.append，这种情况编译器是无法知道其确定值的，只有在运行期才能确定

运行时常量池：

* 在JVM运行时区域的方法区中，存在一块区域为运行时常量池，主要用来存储编译期生成的各种字面量和符号引用
* 运行时常量池相对于编译期常量池的重要特征是具备动态性。Java语言不要求常量一定只有编译期才能产生，也就是并非预置入Class文件常量池的内容才能进入方法区运行时常量池，运行期间也能够将新的常量放入池中
* 在 Java7后移动到堆空间

### 2.2 不可变性

体现：
```private final char value[];```

* String 被声明为final，不可被继承
* 内部存储数据的char数组为final，一旦初始化完毕就不能再引用其他数组
* String内部没有改变char数组的方法，保证了String的不可变性
* private保证外部无法访问

原理：在编译期字面量被加入到常量池，在类加载阶段字面量会进入运行时常量池，但并不会直接将所有字面量全部加载，而是**只加载运行时常量池中不存在的字面量**。当使用new关键字的方式创建字符串对象时：

```java
String s1 = new String("test")
String s2 = new String("test")
```

s1、s2指向两个不同的对象，因为这两个变量作为字符串对象的符号引用保存在栈中，两个字符串对象保存在堆中，而字符串对象指向的同一个字符串字面量则保存在运行时常量池中。可以认为s1、s2是同一个字符串字面量的不同别名而已，但指向字符串对象的任何引用都不能改变它的值

原因：

* **安全性**：若字符串类可变的话，两个引用指向同一个字符串时，改变一个就会影响另一个。String类型常作为参数使用，若可变的话在根据某个String值执行某个操作后其值又发生变化，则会导致不可预料的问题
* **线程安全**：不可变性天生具备线程安全性，可以在多个线程中使用
* **缓存hash**：不可变可以在创建String对象后只计算一次hashcode，之后进行缓存，需要的时候直接返回即可

### 2.3 intern()

作用：

* 将字符串字面量在运行期加入运行时常量池
* **返回字面量的引用**，可以简单的认为如下：

    ```java
    String s1 = "test";
    String s2 = new String("test").intern();
    System.out.println(s1 == s2);//true
    ```

    在不使用intern()时，s2指向的是堆中的对象，但执行intern()后，指向的是字符串常量池中的字符串字面量

使用：很多时候在程序中用到的字符串是只有在运行期才能确定，在编译期无法确定，那么也就没办法在编译期被加入到常量池中。这时对于可能经常使用的字符串，使用intern进行定义，显式加入常量池，每次JVM运行到这段代码时就会直接把常量池中该字面值的引用返回，可以**减少大量字符串对象的创建**。

### 2.4 其他字符串类

**StringBuilder**：

* 可以改善效率问题，是可变的，但同时也是线程不安全的
* 相比于String底层的final char[]，StringBuilder中的char[]不是final的，同时类似于Redis中的SDS，维护一个变量count记录数组中已使用的字符个数

**StringBuffer**：比StringBuilder效率低，因为它是线程安全的，内部使用synchronized同步

**StringJoiner**：通过StringBuilder实现，用于处理集合的字符串拼接，或对一组数据进行拼接并将其转换成Stream后用StringJoiner处理

## 3. 包装类

Java 基本类型的包装类的大部分都实现了常量池技术，即 Byte / Short / Integer / Long / Character / Boolean，这 5 种包装类**默认创建了在 [-128，127] 的相应类型的缓存数据**，超出此范围才会去**创建新的对象（等价于 new Integer()）**，而两种浮点数类型的包装类 Float / Double 并没有实现常量池技术。

自动装箱：如 `Integer i = 1`

* 自动装箱编译的时候会直接将代码封装成 `Integer i = Integer.valueOf(1)`，也就是说**自动装箱会使用常量池**
* 超过而对于使用 new 关键字如 `Integer i = new Integer(1)`，则会创建新的对象。

自动拆箱：

* 加号操作符不适用于 Integer 对象，「+」两边的操作数会自动拆箱操作与数值相加
* Integer 对象无法与数值直接进行比较，对于 `i == 1`，i 会自动拆箱转为 int 值

不可变性：

* 与String类似：```private final int value;```

常量池：

* Integer 数组实现

## 4. 枚举类

常量的集合，所有枚举值都是 public / static / final

定义的常量相当于使用私有构造方法构造出的实例对象

如果要为每个枚举值指定属性，则在枚举中必须声明一个参数为属性对应类型的私有构造方法，私有保证了用户不能新建枚举实例，可以传入多个属性，同时声明私有属性变量，提供getter()

Enum为抽象类，一个类一旦被声明为枚举，其就会继承Enum类，Enum类只有(String name,int ordinal)的构造方法
