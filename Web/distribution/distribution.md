# 分布式

---

## 1. [分布式 ID 生成器](#id_generator)

* 基于 MySQL 的 auto_increament 属性，但是会强依赖于数据库，需要提高数据库可靠性
* 使用本地 UUID，但生成的 ID 无序，不适用于作主键，因为无序的主键会导致 B+  树的结构频繁变动
* 采用时间戳拼接业务 ID，但并发足够高时就无法保证唯一性
* Twitter 雪花算法

当对 ID 生成器的请求次数很高时，还需要保证 ID 的唯一性，就需要加锁，如何提高生成器的性能？

* 给全局 ID 生成器安装多个前置发号器。批量地给每个前置发号器发送特定范围内的 ID，多个前置发号器提高了并发能力
* 直接使用多个 ID 生成器，每个生成器按照一定规则 ID，互不干扰

## 2. 分布式缓存

### 2.1 缓存负载策略

一致性 hash 算法：

* 场景：n 台机器缓存数据，使用 `hash() % n` 的方式将数据分散存储，在访问数据时使用同样的方式可直接获取到目标机器
* 问题：机器数量变动，大量缓存同时失效，出现缓存雪崩
* **hash 环**：将 hash 空间 [0, 2^32-1] 看作一个环，使用 `hash（机器唯一标识） % 2^32` 得到的机器在 hash 环中的位置，同理也能得到数据在 hash 环中的位置，数据存储在顺时针方向遇到的第一台机器中。这种方式使得在机器数量变动时，只有少部分的缓存会失效，避免了缓存雪崩
* **hash 环的偏斜**：机器在 hash 环上的分布不均匀，导致大量的缓存集中在某几台机器上，这时可以使用虚拟节点的方式，将物理机器映射成均匀分布在环中的多个虚拟节点，使得缓存分布均匀

### 2.2 缓存更新策略

#### 2.2.1 双写一致性

需要明确的是，如果对数据库有强一致性要求，那么就不能使用缓存，Redis 只能保证最终一致性。采用正确的更新策略：**先更新数据库，再删除缓存**。

为什么不能先删缓存在更新数据库？

* 并发读写时，写操作先删除了缓存，而查询未命中缓存，在数据库中读到了旧数据并放到了缓存中，此时写操作更新了数据库，导致缓存出现了脏数据
* 如果写操作先更新数据库，查询获得的是旧数据，写操作再删除缓存，后续的查询未命中则会读取到新数据，并更新了缓存

需要注意的是，当删除缓存失败时要提供补偿措施：可以在更新数据库成功以后向消息队列发送消息，由消息队列保证未被删除的 key 会被成功删除。

#### 2.2.2 [并发写](#concurrentWriteCache)

Redis 是单线程模型，不存在并发问题，但是业务中会出现多个线程或多个 redis client 写同一个 key 的情况，此时就需要进行同步操作：

* 使用分布式锁
* 将数据写入消息队列，由单线程更新缓存
* 使用时间戳：set 时同时设置时间戳，那么后抢到锁的子系统如果发现自己的时间戳早于缓存中存在的，就不再进行 set 操作，因为此时缓存中值已经比自己持有的值新

后两种方法可以在同步的同时按一定顺序写入。

## 3. 分布式 Session

借助 Redis 实现：

1. 当用户登录时，使用分布式 ID 生成器作为 key，将查找到的用户 id 作为 value 存入 Redis，设置过期时间
2. 将 key 放入 Cookie 中返回客户端
3. 登录成功访问其他页面时，前端使用拦截器将之前 Cookie 中拿到的 Session id 一并发送至后端
4. 后端拿到 Session id 在 Redis 中查找即可

需要注意的：

* 用户在操作的过程中 key 过期，用户被强制退出：key 中加入时间戳，每次查询时查看过期时间与当前时间的差值，如果小于某个值，刷新 key 即可

## 4. CAP & BASE

CAP 指一致性（Consistency）、可用性（Availability）、分区容忍性（Partition Tolerance），分布式系统的这三者无法同时满足。

> 如何理解 CAP 的「三选二」？
> 保存数据的节点越多， P 就越高，但需同步的数据就越多，C 就越难保证，而为了保证 C，每次同步数据就需要等待各个节点的统一，会导致 A 的降低。

分布式系统中 P 是必须保证的，因为网络不是可靠的，会造成节点间的失联；所以一般会在 C 和 A 之间进行权衡：

* CP 能保证一致性，但无法访问未同步完成的节点
* AP 可以保证可用性，可以访问所有节点，但数据会不一致

Redis、Git 都是是牺牲 A 满足 CP 的例子，它们需要优先保证数据是一致的，而大多数高并发的网站则是 AP，如秒杀时为了保证并发量而出现下单失败这种数据不一致也是可以容忍的。

而 BASE 则是対 CAP 中 C 和 A 权衡的结果：即使无法做到强一致性，也需要采用适当的方式达到最中一致性。

* BA（Basically Available）：基本可用，就是说分布式系统在核心可用下允许部分故障
* S（Soft State）：软状态，不影响系统整体可用性下允许数据存在中间状态，如数据正在同步
* E（Eventually Consistency）：最终一致性，需要注意的是 **ACID 要求的是强一致性**
